%{

#include <iostream> // cerr, endl
#include <string> // string
#include <unordered_map> // unordered_map
#include <vector> // vector
#include <memory> // unique_ptr

#include "ast.hpp"
#include "types.hpp"


/*
* @brief Extern lexical parsing function.
*/
extern int yylex();

/*
* @brief Error handling function.
*/
void yyerror(std::string_view msg)
{
	std::cerr << "[yyerror] " << msg << std::endl;
	std::exit(1);
}

// @brief Global symbol table with identifiers and types.
std::unordered_map<std::string, pascalina::types::base*> type_map;
// @brief Program tree
std::unique_ptr<pascalina::program> root;

%}

/* Defining yacc union */
%union
{
	/* Expressions */
	pascalina::expression *expression;
	std::vector<pascalina::expression*> *expression_list;
	/* Identifiers */
	std::string *identifier;
	std::vector<std::string> *identifier_list;
	/* Statements */
	pascalina::statement *statement;
	std::vector<pascalina::statement*> *statement_list;
	/* Subprograms */
	pascalina::function *subprogram_declaration;
	pascalina::function_prototype *subprogram_head;
	std::vector<pascalina::function*> *subprogram_declarations;
	/* Types */
	pascalina::types::base *type;
	/* Misc */
	pascalina::var *declarations;
	float literal;
}

/* Defining tokens */
%token ID NUM VAR
%token IF ELSE THEN DO FUNCTION PROCEDURE WHILE
%token ARRAY ELIPSIS OF INTEGER REAL
%token PROGRAM BEGIN_ END_
%token EQ NE LE GE ASSIGN NOT

/* Defining types */
%type<declarations> declarations
%type<identifier_list> var var_list identifier_list
%type<type> base_type type
%type<subprogram_declarations> subprogram_declarations
%type<subprogram_declaration> subprogram_declaration
%type<subprogram_head> subprogram_head
%type<identifier_list> parameter_list arguments
%type<statement_list> statement_list optional_statements
%type<statement> statement compound_statement
%type<expression> variable
%type<statement> procedure_statement
%type<expression_list> expression_list
%type<expression> expression

%type<literal> NUM
%type<identifier> ID



/* Handling token precedence for conditional statements */
%nonassoc THEN
%nonassoc ELSE

/* Setting operator precedence */
%left EQ NE
%left '<' '>' LE GE
%left '+' '-'
%left '*' '/'
%right NOT

%%

/* pascalina::program */
program
	: PROGRAM ID ';' declarations subprogram_declarations compound_statement '.' {
			//root = std::make_unique<pascalina::program>(*$2, $4, *$5, $6);
			delete $2; /* std::string */
			delete $5; /* std::vector<pascalina::function*> */
		}
	;

/* std::vector<std::string> */
identifier_list
	: ID {
			$$ = new std::vector<std::string>{*$1};
			delete $1; /* std::string */
		}
	| identifier_list ',' ID {
			$$ = $1;
			$$->push_back(*$3);
			delete $3; /* std::string */
		}
	;

/* pascalina::var */
declarations
	: VAR var_list {
			$$ = new pascalina::var(*$2);
			delete $2; /* std:::vector<std::string> */
		}
	;

/* std::vector<std::string> */
var_list
	: var { $$ = new std::vector<std::string>($1->begin(), $1->end()); }
	| var_list var {
			$$ = $1;
			$$->insert($$->end(), $2->begin(), $2->end());
			delete $2; /* std::vector<std::string> */
		}
	;

/* std:::vector<std::string> */
var
	: identifier_list ':' type ';' {
			$$ = new std::vector<std::string>($1->begin(), $1->end());

			for(auto &&e : *$1) {
				type_map[e] = $3->clone();
			}

			delete $1; /* std::string */
			delete $3; /* pacalina::types::base */
		}
	;

/* pacalina::types::base */
type
	: base_type { $$ = $1; }
	| ARRAY '[' NUM ELIPSIS NUM ']' OF base_type {
			$$ = new pascalina::types::array($8, $5);
		}
	;

/* pacalina::types::base */
base_type
	: INTEGER { $$ = new pascalina::types::integral; }
	| REAL { $$ = new pascalina::types::real; }
	;

/* std::vector<pascalina::function*> */
subprogram_declarations
	: subprogram_declarations subprogram_declaration ';' {
			$$ = $1;
			$$->push_back($2);
		}
	| /* eps */ { $$ = new std::vector<pascalina::function*>; }
	;

/* pascalina::function */
subprogram_declaration
	: subprogram_head declarations compound_statement { $$ = new pascalina::function($1, $2, $3); }
	;

/* pascalina::function_prototype */
subprogram_head
	: FUNCTION ID arguments ':' base_type ';' {
			$$ = new pascalina::function_prototype(*$2, *$3);
			type_map[*$2] = $5;
			delete $2; /* std::string */
			delete $3; /* std::vector<std::string> */
		}
	| PROCEDURE ID arguments ';' {
			$$ = new pascalina::function_prototype(*$2, *$3);
			type_map[*$2] = new pascalina::types::integral;
			delete $2; /* std::string */
			delete $3; /* std::vector<std::string> */
		}
	;

/* std::vector<std::string> */
arguments
	: '(' parameter_list ')' { $$ = $2; }
	| /* eps */ { $$ = new std::vector<std::string>; }
	;

/* std::vector<std::string> */
parameter_list
	: identifier_list ':' type {
			$$ = new std::vector<std::string>($1->begin(), $1->end());

			for(auto &&e : *$1) {
				type_map[e] = $3->clone();
			}

			delete $1; /* std::vector<std::string> */
			delete $3; /* pacalina::types::base */
		}
	| parameter_list ';' identifier_list ':' type {
			$$ = $1;
			$$->insert($$->end(), $3->begin(), $3->end());

			for(auto &&e : *$3) {
				type_map[e] = $5->clone();
			}

			delete $3; /* std::vector<std::string> */
			delete $5; /* pacalina::types::base */
		}
	;

/* pascalina::statement */
compound_statement
	: BEGIN_ optional_statements END_ {
			$$ = new pascalina::compound(*$2);
			delete $2; /* std::vector<pascalina::statement*> */
		}
	;

/* std::vector<pascalina::statement*> */
optional_statements
	: statement_list { $$ = $1; }
	| /* eps */ { $$ = new std::vector<pascalina::statement*>; }
	;

/* std::vector<pascalina::statement*> */
statement_list
	: statement { $$ = new std::vector<pascalina::statement*>{$1}; }
	| statement_list ';' statement {
			$$ = $1;
			$$->push_back($3);
		}
	;

/* pascalina::statement */
statement
	: variable ASSIGN expression { $$ = new pascalina::assignment($1, $3); }
	| procedure_statement { $$ = $1; }
	| compound_statement { $$ = $1; }
	| IF expression THEN statement ELSE statement { $$ = new pascalina::selection($2, $4, $6); }
	| IF expression THEN statement { $$ = new pascalina::selection($2, $4); }
	| WHILE expression DO statement { $$ = new pascalina::iteration($2, $4); }
	;

/* pascalina::expression */
variable:
	ID {
			$$ = new pascalina::identifier(*$1);
			delete $1; /* std::string */
		}
	| ID '[' expression ']' {
			//$$ = new pascalina::indexing(*$1, $3);
			delete $1; /* std::string */
		}
	;

/* pascalina::statement */
procedure_statement
	: ID {
			//$$ = new pascalina::function_call(*$1);
			delete $1; /* std::string */
		}
	| ID '(' expression_list ')' {
			//$$ = new pascalina::function_call(*$1, *$3);
			delete $1; /* std::string */
			delete $3; /* std::vector<pascalina::expression*> */
		}
	;

/* std::vector<pascalina::expression*> */
expression_list
	: expression { $$ = new std::vector<pascalina::expression*>{$1}; }
	| expression_list ',' expression {
			$$ = $1;
			$$->push_back($3);
		}
	;

/* pascalina::expression */
expression
	: expression '+' expression { $$ = new pascalina::binary_operator(pascalina::binary::plus, $1, $3); }
	| expression '-' expression { $$ = new pascalina::binary_operator(pascalina::binary::minus, $1, $3); }
	| expression '*' expression { $$ = new pascalina::binary_operator(pascalina::binary::multiplies, $1, $3); }
	| expression '/' expression { $$ = new pascalina::binary_operator(pascalina::binary::divides, $1, $3); }
	| expression '<' expression { $$ = new pascalina::binary_operator(pascalina::binary::less, $1, $3); }
	| expression '>' expression { $$ = new pascalina::binary_operator(pascalina::binary::greater, $1, $3); }
	| expression EQ expression { $$ = new pascalina::binary_operator(pascalina::binary::equal_to, $1, $3); }
	| expression NE expression { $$ = new pascalina::binary_operator(pascalina::binary::not_equal_to, $1, $3); }
	| expression LE expression { $$ = new pascalina::binary_operator(pascalina::binary::less_equal, $1, $3); }
	| expression GE expression { $$ = new pascalina::binary_operator(pascalina::binary::greater_equal, $1, $3); }
	| '-' %prec '-' expression { $$ = new pascalina::unary_operator(pascalina::unary::minus, $2); }
	| NOT expression { $$ = new pascalina::unary_operator(pascalina::unary::logical_not, $2); }
	| '(' expression ')' { $$ = $2; }
	| ID {
			$$ = new pascalina::identifier(*$1);
			delete $1;
		}
	| ID '(' expression_list ')' {
			$$ = new pascalina::function_call(*$1, *$3);
			delete $1; /* std::string */
			delete $3; /* std::vector<pascalina::expression*> */
		}
	| NUM { $$ = new pascalina::literal($1); }
	;

%%
